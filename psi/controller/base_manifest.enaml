import enaml
from enaml.application import deferred_call
from enaml.layout.api import InsertItem
from enaml.widgets.api import Action
from enaml.workbench.api import Extension, ExtensionPoint, PluginManifest
from enaml.workbench.core.api import Command
from enaml.workbench.ui.api import ActionItem, MenuItem

from psi.experiment.api import Preferences
from ..util import rpc


def _contribute_outputs(workbench, workspace):
    from .output_view import OutputDockItem
    plugin = workbench.get_plugin('psi.controller')
    item = OutputDockItem(workspace.dock_area, controller=plugin,
                          name='controller_outputs', title='Outputs')
    op = InsertItem(item=item.name, position='top')
    deferred_call(workspace.dock_area.update_layout, op)


def _contribute_plots(workbench, workspace):
    plugin = workbench.get_plugin('psi.controller')
    pass


def contribute_to_workspace(workbench, workspace):
    _contribute_outputs(workbench, workspace)
    _contribute_plots(workbench, workspace)


def load_calibration(event):
    with enaml.imports():
        from .calibration_dialog import CalibrationDialog
    controller = event.workbench.get_plugin('psi.controller')
    CalibrationDialog(controller=controller).show()


enamldef ControllerManifest(PluginManifest): manifest:
    '''
    Defines the core functionality that most controller plugins will share
    (start, stop, pause, apply/revert settings).
    '''
    ExtensionPoint:
        id = 'psi.controller.io'

    ExtensionPoint:
        id = 'psi.controller.actions'

    Extension:
        id = 'commands'
        point = 'enaml.workbench.core.commands'
        Command:
            id = 'psi.controller.start'
            handler = rpc('psi.controller', 'start_experiment')
        Command:
            id = 'psi.controller.stop'
            handler = rpc('psi.controller', 'stop_experiment')
        Command:
            id = 'psi.controller.next_trial'
            handler = rpc('psi.controller', 'end_trial')
        Command:
            id = 'psi.controller.request_apply'
            handler = rpc('psi.controller', 'request_apply')
        Command:
            id = 'psi.controller.request_pause'
            handler = rpc('psi.controller', 'request_pause')
        Command:
            id = 'psi.controller.request_resume'
            handler = rpc('psi.controller', 'request_resume')
        Command:
            id = 'psi.controller.load_calibration'
            handler = load_calibration


    # Uses unicode symbols as icons for sake of simplicity.
    Extension:
        id = 'toolbar'
        rank = 1
        point = 'psi.experiment.toolbar'
        Action:
            text = u'\u27A4 Start'
            tool_tip = 'Start experiment'
            triggered ::
                plugin = workbench.get_plugin('enaml.workbench.core')
                plugin.invoke_command('psi.controller.start')
            enabled << workbench.get_plugin('psi.controller').experiment_state \
                == 'initialized'
        Action:
            text = u'\u23F9 Stop'
            tool_tip = 'Stop experiment'
            triggered ::
                plugin = workbench.get_plugin('enaml.workbench.core')
                plugin.invoke_command('psi.controller.stop')
            enabled <<  workbench.get_plugin('psi.controller').experiment_state \
                not in ('initialized', 'stopped')
        Action:
            separator = True
        Action:
            text << u'\u23E9 Resume' if checked else u'\u23F8 Pause'
            checkable = True
            enabled <<  workbench.get_plugin('psi.controller').experiment_state \
                not in ('initialized', 'stopped')
            tool_tip << 'Resume' if checked else 'Pause'
            toggled ::
                plugin = workbench.get_plugin('enaml.workbench.core')
                if checked:
                    plugin.invoke_command('psi.controller.request_pause')
                else:
                    plugin.invoke_command('psi.controller.request_resume')
        Action:
            separator = True

        # Apply/Revert logic should pass through the controller so we can
        # ensure that the changes occur at the appropriate time in a trial
        # (i.e., in between trials). 
        Action:
            text = 'Apply'
            enabled << workbench.get_plugin('psi.context').changes_pending \
                and not workbench.get_plugin('psi.controller')._apply_requested \
                and workbench.get_plugin('psi.controller').experiment_state \
                in ('running', 'paused')
            triggered :: 
                plugin = workbench.get_plugin('enaml.workbench.core')
                plugin.invoke_command('psi.controller.request_apply')
        Action:
            text = 'Revert'
            enabled << workbench.get_plugin('psi.context').changes_pending \
                and workbench.get_plugin('psi.controller').experiment_state \
                in ('running', 'paused')
            triggered :: 
                plugin = workbench.get_plugin('enaml.workbench.core')
                plugin.invoke_command('psi.context.revert_changes')

    Extension:
        id = 'base_actions'
        point = 'enaml.workbench.ui.actions'
        MenuItem:
            path = '/equipment'
            label = 'Equipment'

        MenuItem:
            path = '/configuration/calibration'
            label = 'Calibration'

        ActionItem:
            path = '/configuration/calibration/load_calibration'
            label = 'Load calibration files'
            command = 'psi.controller.load_calibration'

    Extension:
        id = 'base_workspace'
        point = 'psi.experiment.workspace'
        factory = contribute_to_workspace

    Extension:
        id = 'preferences'
        point = 'psi.experiment.preferences'
        Preferences:
            name = 'controller_outputs'
            get_preferences => (workbench):
                plugin = workbench.get_plugin(manifest.id)
                return dict((n, o._token_name) \
                            for n, o in plugin._outputs.items())

            set_preferences => (workbench, preferences):
                plugin = workbench.get_plugin(manifest.id)
                if preferences is None:
                    return
                for output_name, token_name in preferences.items():
                    plugin.configure_output(output_name, token_name)
